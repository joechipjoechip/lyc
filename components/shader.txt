// shader pas mal, coulant, color√©, qui fonctionne tel quel

vertexShader: `
    varying vec2 vUv;
    varying vec2 iResolution;
    void main()
    {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
        vec4 viewPosition = viewMatrix * modelPosition;
        vec4 projectedPosition = projectionMatrix * viewPosition;
        gl_Position = projectedPosition;
        vUv = uv;
    }
`,
fragmentShader: `
    uniform float iTime;
    uniform vec2 iResolution;

    varying vec2 vUv;

    float PI = 3.14159265359;
    
    vec2 rot(vec2 p,float a)
    {
        float c=cos(a*12.);
        float s=sin(a*12.);
        return p*mat2(s,c,c,-s);
    }

    void main()
    {
        vec2 uv = vec2(vUv.xy);
        // vec2 uv = clamp(vUv.xy,0.,0.8);
        uv/=iResolution.xx;
        uv=vec2(.125,.75)+(uv-vec2(-.9125,.75))*.23;
        float T=iTime*0.75;

        vec3 c = clamp(1.-.4*vec3(
            length(uv-vec2(.1,0)),
            length(uv-vec2(.01,0)),
            length(uv-vec2(.05,1))
        ),0.,1.)*1.7-1.;

        vec3 c0=vec3(0);
        float w0=0.;
        const float N=20.;
        for(float i=0.;i<N;i++)
        {
            float wt=(i*i/N/N-.2)*.3;
            float wp=0.5+(i+1.)*(i+2.5)*0.001;
            float wb=.8+i/N*0.1;
            c.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);
            c.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);
            c.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/5.)-0.925)*2.)*1.*wp);
            c.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.17)*23.*wp);
            c.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);
            float w=(1.5-i/N)*.5;
            c0+=c*w;
            w0+=w;
        }
        c0=c0/w0*1.9+.5;//*(1.-pow(uv.y-.5,2.)*2.)*10.+.5;
        c0*=.5+dot(c0,vec3(1,1,1))/sqrt(3.)*.4;
        c0+=pow(length(sin(c0*PI*10.))/sqrt(3.)*1.0,20.)*(.3+.7*c0);
        //c0 = clamp(c0, 0., uv.y);
        gl_FragColor=vec4(c0,1.0);
    }
`